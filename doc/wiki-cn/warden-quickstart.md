# Ready to work

It is recommended to use [kratos tool](kratos-tool.md) to quickly generate projects, such as we generate a project called `kratos-demo`.

[Quick Start](quickstart.md)

# Pb file

After creating the project successfully, you can see the `api.proto` and `api.pb.go` and `generate.go` files in the `api` directory, where:
* `api.proto` is the description file of gRPC server
* `api.pb.go` is a code file generated based on `api.proto`
* `generate.go` is a temporary file used by `kratos tool` to execute `go generate` for code generation.

Next, you can delete all the above three files or keep `generate.go`, then write your own proto file, and confirm that proto is correct, then generate code:
* Directly execute `kratos tool kprotoc`, which will call the protoc tool to generate `.pb.go` files.
* If `generate.go` is not deleted, you can also execute the `go generate` command, which will call the `kratos tool kprotoc` tool for code generation.

#registered server

Go to the `internal/server/grpc` directory and open the `server.go` file. You can see the following code. You only need to replace the following comments to start a gRPC service.

```go
Package grpc

Import (
Pb "kratos-demo/api"
"kratos-demo/internal/service"
"github.com/bilibili/kratos/pkg/conf/paladin"
"github.com/bilibili/kratos/pkg/net/rpc/warden"
)

// New new a grpc server.
Func New(svc *service.Service) *warden.Server {
Var rc struct {
Server *warden.ServerConfig
}
If err := paladin.Get("grpc.toml").UnmarshalTOML(&rc); err != nil {
If err != paladin.ErrNotExist {
Panic(err)
}
}
Ws := warden.NewServer(rc.Server)
// Note to replace here:
// The RegisterDemoServer method is generated in the "api" directory.
// Correspond to the custom service name in the proto file, please replace it with the correct method name.
pb.RegisterDemoServer(ws.Server(), svc)
Ws, err := ws.Start()
If err != nil {
Panic(err)
}
Return ws
}
```

### Registration Note

```go
// SayHello grpc demo func.
Func (s *Service) SayHello(ctx context.Context, req *pb.HelloReq) (reply *empty.Empty, err error) {
Reply = new(empty.Empty)
fmt.Printf("hello %s", req.Name)
Return
}
```

Please go to `internal/service` to find the `SayHello` method. Note that the method's input and output parameters are declared according to the gRPC method:
* The first parameter must be `context.Context`, and the second must be the structure generated by `message` defined in proto.
* The first return value must be the corresponding structure generated by `message` defined in proto. The second parameter must be `error`.
* In the http framework bm, if the shared proto file generates bm code, then you can also use the service method directly.

It is recommended that the service declare the method strictly according to this format, so that it can be shared between bm and warden.

#clientcall

Please enter the `internal/dao` method, generally the processing of resources will be encapsulated in this layer.
For the `client` side, the premise must have the code generated by the `proto` file, then there are two options:

* Copy proto files to your own project and execute code generation
* Direct import server api package

***PS: This is also the business code. We add a layer of `internal` relationship. The service only exposes the interface ***

Either way, the following code to initialize the gRPC client is recommended to be stored in a unified directory with the generated code:

```go
Package dao

Import (
"context"

"github.com/bilibili/kratos/pkg/net/rpc/warden"

"google.golang.org/grpc"
)

// AppID unique app id for service discovery
Const AppID = "your app id"

// NewClient new member grpc client
Func NewClient(cfg *warden.ClientConfig, opts ...grpc.DialOption) (DemoClient, error) {
Client := warden.NewClient(cfg, opts...)
Conn, err := client.Dial(context.Background(), "discovery://default/"+AppID)
If err != nil {
Return nil, err
}
// Note to replace here:
// The NewDemoClient method is generated in the "api" directory.
// Correspond to the custom service name in the proto file, please replace it with the correct method name.
Return NewDemoClient(conn), nil
}
```

Among them, `"discovery://default/"+AppID` is the gRPC target, which is provided to the resolver for discovery service discovery. If other components are found using other services, they can be imported according to their own implementation.

With the code to initialize `Client`, our `Dao` object can be initialized and used. The following is an example of directly importing the server api package:

```go
Package dao

Import(
Demoapi "kratos-demo/api"
Grpcempty "github.com/golang/protobuf/ptypes/empty"

"github.com/pkg/errors"
)

Type Dao struct{
demoClient demoapi.DemoClient
}

// New account dao.
Func New(c *conf.Config) (d *Dao) {
d = &Dao{}
Var err error
If d.demoClient, err = demoapi.NewClient(c.DemoRPC); err != nil { // NOTE: DemoRPC is the ClientConfig object in the warden package
Panic(err)
}
Return
}

// SayHello say hello.
Func (d *Dao) SayHello(c context.Context, req *demoapi.HelloReq) (resp *grpcempty.Empty, err error) {
If resp, err = d.demoClient.SayHello(c, req); err != nil {
Err = errors.Wrapf(err, "%v", arg)
}
Return
}
```

So in the `internal/service` layer you can make resource method calls.

# Extended reading

[warden interceptor](warden-mid.md) [warden based on pb generation](warden-pb.md) [warden service discovery](warden-resolver.md) [warden load balancing](warden-balancer.md)

-------------

[document directory tree](summary.md)